#####################
listing of options: https://sites.ualberta.ca/dept/chemeng/AIX-43/share/man/info/C/a_doc_lib/cmds/aixcmds1/ar.htm
##############################3
A simple way is to compile with

gfortran myprog.f90  -I/path/to/mod_files -L /path/to/lib -lmylib

where the module.mod are in the directory /path/to/mod_files. The module.o was generated by

gfortran -c /path/to/mod_files/module.f90

and the library mylib.a was generated by

ar rcv /path/to/lib/mylib.a /path/to/mod_files/module.o

But you still have to keep the .mod files.
#####################################################################
From:  https://kacv.net/brad/engr325/gfortrancompile.pdf
--------------------
Using gfortran with external libraries and module files
Suppose we have the following directory structure
/home/baf1/modules (directory containing module .mod files)
/home/baf1/lib (directory containing object code libraries as .a files)
Compile files containing modules and external subprograms using
gfortran -c <source filename>
If file twomods.f90 that contains modules mod1 and mod2 then
gfortran -c twomods.f90
produces the files twomods.o, mod1.mod, and mod2.mod
If file twosubs.f90 that contains subroutine sub1 and function fun1 then
gfortran -c twosubs.f90
produces the file twosubs.o
Copy .mod files to the module directory
cp *.mod <module directory>
In our example
cp mod1.mod mod2.mod /home/baf1/modules
Add object files to the appropriate object code archive (library) using
ar -qs <library filename> <list of object file names>
In our example, adding files twomods.o and twosubs.o to library file libbase1.a
ar -qs /home/baf1/lib/libbase1.a twomods.o twosubs.o
Note: during the link phase below, the library file name is assume to be prefaced with
lib, so use that convention when creating the file.
Note: to replace an object file in a archive (library) use
ar -rs <library filename> <list of object file names>
In our example, to replace existing file twosubs.o in library file libbase1.a with a
new version
ar -rs /home/baf1/lib/libbase1.a twosubs.o
Compile Fortran source code that uses modules and object code stored in a library
gfortran <source filename> -J<path to modules directory> \
-L<path to library directory> -l<library name> \
-o <executable filename>
To compile laba4.f90 which references mod1, mod2, and fun1
gfortran laba4.f90 -J/home/baf1/modules -L/home/baf1/lib \
-lbase1 -o laba4
###################################################################

From: https://docs.oracle.com/cd/E19957-01/805-4940/6j4m1u7ov/index.html
**************************************************
Creation of a Simple Static Library

Suppose that you can distribute all the routines in a program over a group of source files and that these files are wholly contained in the subdirectory test_lib/.

Suppose further that the files are organized in such a way that they each contain a single principal subprogram that would be called by the user program, along with any "helper" routines that the subprogram might call but that are called from no other routine in the library. Also, any helper routines called from more than one library routine are gathered together into a single source file. This gives a reasonably well-organized set of source and object files.

Assume that the name of each source file is taken from the name of the first routine in the file, which in most cases is one of the principal files in the library:

demo% cd test_lib
demo% ls
total 14          2 dropx.f      2 evalx.f      2 markx.f
   2 delte.f      2 etc.f        2 linkz.f      2 point.f

The lower-level "helper" routines are gathered together into the file etc.f. The other files can contain one or more subprograms.

First, compile each of the library source files, using the -c option, to generate the corresponding relocatable .o files:

demo% f77 -c *.f
delte.f:
    delte:
    q_fixx:
dropx.f:
    dropx:
etc.f:
    q_fill:
    q_step:
    q_node:
    q_warn:
 ...etc
demo% ls
total 42   
 2 dropx.f     4 etc.o      2 linkz.f    4 markx.o   
 2 delte.f     4 dropx.o    2 evalx.f    4 linkz.o     2 point.f
 4 delte.o     2 etc.f      4 evalx.o    2 markx.f     4 point.o
demo%

Now, create the static library testlib.a using ar:

demo% ar cr testlib.a *.o

To use this library, either include the library file on the compilation command or use the -l and -L compilation options. The example uses the .a file directly:

demo% cat trylib.f
C    program to test testlib routines
            x=21.998
            call evalx(x)
            call point(x)
            print*, 'value ',x
            end
demo% f77 -o trylib trylib.f test_lib/testlib.a
trylib.f:
 MAIN:
demo%

Notice that the main program calls only two of the routines in the library. You can verify that the uncalled routines in the library were not loaded into the executable file by looking for them in the list of names in the executable displayed by nm:

demo% nm trylib | grep FUNC | grep point
[146]      |     70016|     152|FUNC |GLOB |0    |8      |point_
demo% nm trylib | grep FUNC | grep evalx
[165]      |     69848|     152|FUNC |GLOB |0    |8      |evalx_
demo% nm trylib | grep FUNC | grep delte
demo% nm trylib | grep FUNC | grep markx
demo% ..etc

In the preceding example, grep finds entries in the list of names only for those library routines that were actually called.

Another way to reference the library is through the -llibrary and -Lpath options. Here, the library's name would have to be changed to conform to the libname.a convention:

demo% mv test_lib/testlib.a test_lib/libtestlib.a
demo% f77 -o trylib trylib.f -Ltest_lib -ltestlib
trylib.f:
 MAIN:

The -llibrary and -Lpath options are used with libraries installed in a commonly accessible directory on the system, like /usr/local/lib, so that other users can reference it. For example, if you left libtestlib.a in /usr/local/lib, other users could be informed to compile with the following command:

demo% f77 -o myprog myprog.f -L/usr/local/lib -ltestlib
=======================
Replacement in a Static Library

It is not necessary to recompile an entire library if only a few elements need recompiling. The -r option of ar permits replacement of individual elements in a static library.

Example: Recompile and replace a single routine in a static library:

demo% f77 -c point.f 
demo% ar r testlib.a point.o 
demo%
======
Ordering Routines in a Static Library

To order the elements in a static library when it is being built by ar, use the commands lorder(1) and tsort(1):

demo% ar cr mylib.a 'lorder exg.o fofx.o diffz.o | tsort'

******************************************************************
  

IDIR =../include
CC=gcc
CFLAGS=-I$(IDIR)

ODIR=obj
LDIR =../lib

LIBS=-lm

_DEPS = hellomake.h
DEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))

_OBJ = hellomake.o hellofunc.o 
OBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))


$(ODIR)/%.o: %.c $(DEPS)
	$(CC) -c -o $@ $< $(CFLAGS)  # $< the first argument on the right of :

hellomake: $(OBJ)
	$(CC) -o $@ $^ $(CFLAGS) $(LIBS)  # $^  all on the right of the :

.PHONY: clean

clean:
	rm -f $(ODIR)/*.o *~ core $(INCDIR)/*~ 

============================================

Macros:


    $@ is the name of the file to be made.
    $? is the names of all the changed dependents.	
    $< the name of the related file that caused the action.
    $* the prefix shared by target and dependent files.
$?    The names of all the prerequisites that are newer than the target, with spaces between them. For prerequisites which are archive members, only the named member is used (see Archives).



to run, use either
make hellomake
make clean
-------------------
# Below we are replacing the suffix .c of all words in the macro SRCS
# with the .o suffix
#
OBJS = $(SRCS:.c=.o)




-------------
FC = gfortran
FCFLAGS = -fcheck=all -fno-automatic -finit-local-zero
#FCFLAGS =

BASEDIR=C:\Users\Olaf\Documents\AstroPhys\Lunatic
INTDIR=$(BASEDIR)\LunarAcc\debug
HOMEDIR=$(BASEDIR)\fortran
MFD=$(BASEDIR)\fortran
ext=F90

SR11=NMCntR
NoDepcs= $(MFD)/LunarAcc.F90 $(MFD)/Shower.F90 $(MFD)/Plot_Show.F90 $(MFD)/sq2tria-2.F90 $(MFD)/tria_fill-2.F90
No1:=$(filter %.$(ext),$(NoDepcs))
No1O := $(No1:%.$(ext)=%.obj)

LINK32_OBJS= $(No1O) 

$(HOMEDIR)\NMAcc.exe : $(LINK32_OBJS) 
	$(FC) $(FCFLAGS) $(LINK32_OBJS) -o $@

$(No1O) : %.obj :  %.$(ext)
	$(FC) $(FCFLAGS) -c -o $@ $<



#h5fc unfolds to:
#gfortran -I/usr/local/hdf5/include -c LOFAR-Imag.f90 /home/olaf/NumLib/bin/libfftpack5.1d.a -fcheck=bounds -fPIC
# #gfortran: warning: /home/olaf/NumLib/bin/libfftpack5.1d.a: linker input file unused because linking not done
#
#gfortran -I/usr/local/hdf5/include LOFAR-Imag.o -o LOFAR-Imag -lm /home/olaf/NumLib/bin/libfftpack5.1d.a -fcheck=bounds -fPIC -L/usr/local/hdf5/lib /usr/local/hdf5/lib/libhdf5hl_fortran.a /usr/local/hdf5/lib/libhdf5_hl.a /usr/local/hdf5/lib/libhdf5_fortran.a /usr/local/hdf5/lib/libhdf5.a -lz -ldl -lm -Wl,-rpath -Wl,/usr/local/hdf5/lib
New (2022):
+ gfortran -g -O2 -fdebug-prefix-map=/build/hdf5-X9JKIg/hdf5-1.10.0-patch1+docs=. -fstack-protector-strong -I/usr/include/hdf5/serial -c LOFAR-Imag.f90 /home/olaf/NumLib/bin/libfftpack5.1d.a -fcheck=bounds

+ gfortran -g -O2 -fdebug-prefix-map=/build/hdf5-X9JKIg/hdf5-1.10.0-patch1+docs=. -fstack-protector-strong -I/usr/include/hdf5/serial LOFAR-Imag.o -o 
LOFAR-Imag -lm /home/olaf/NumLib/bin/libfftpack5.1d.a -fcheck=bounds -L/usr/lib/x86_64-linux-gnu/hdf5/serial /usr/lib/x86_64-linux-gnu/hdf5/serial/libhdf5hl_fortran.a /usr/lib/x86_64-linux-gnu/hdf5/serial/libhdf5_hl.a /usr/lib/x86_64-linux-gnu/hdf5/serial/libhdf5_fortran.a /usr/lib/x86_64-linux-gnu/hdf5/serial/libhdf5.a -Wl,-Bsymbolic-functions -Wl,-z,relro -lpthread -lsz -lz -ldl -lm -Wl,-rpath -Wl,/usr/lib/x86_64-linux-gnu/hdf5/serial


results in:
# ${H5TOOL_BIN} -o $Prog $SourceCode ${LIBRARY} ${FCFLAGS}
#${H5TOOL_BIN} -o $Prog $SourceCode ${LOFLILIB}  ${FCFLAGS} -echo  # gives something like
H5options="-g -O2 -fdebug-prefix-map=/build/hdf5-X9JKIg/hdf5-1.10.0-patch1+docs=. -fstack-protector-strong -I/usr/include/hdf5/serial"
H5Link="-L/usr/lib/x86_64-linux-gnu/hdf5/serial /usr/lib/x86_64-linux-gnu/hdf5/serial/libhdf5hl_fortran.a /usr/lib/x86_64-linux-gnu/hdf5/serial/libhdf5_hl.a /usr/lib/x86_64-linux-gnu/hdf5/serial/libhdf5_fortran.a /usr/lib/x86_64-linux-gnu/hdf5/serial/libhdf5.a -Wl,-Bsymbolic-functions -Wl,-z,relro -lpthread -lsz -lz -ldl -lm -Wl,-rpath -Wl,/usr/lib/x86_64-linux-gnu/hdf5/serial"
gfortran ${H5options} -I./modules -c ${SourceCode} ${FCFLAGS}
gfortran ${H5options} -I./modules ${Prog}.o -o ${Prog} -lm ./libLOFLI.a ${LIBRARY} ${FCFLAGS} ${H5Link}
./libLOFLI.a(HDF5_LOFAR_Read.o): In function `op_func':
HDF5_LOFAR_Read.f90:(.text+0xf5): undefined reference to `__h5global_MOD_h5o_type_group_f'
HDF5_LOFAR_Read.f90:(.text+0x104): undefined reference to `__h5global_MOD_h5o_type_dataset_f'
...
